# Patterns of Enterprise Application Architecture

## ドメインロジック・パターン (Domain Logic Patterns)

* **トランザクションスクリプト (Transaction Script)**
    プレゼンテーション層からの単一のリクエストを、手続き（プロシージャ）ごとにビジネスロジックを整理して処理する。
* **ドメインモデル (Domain Model)**
    データと振る舞いの両方を併せ持った、ドメインのオブジェクトモデル。
* **テーブルモジュール (Table Module)**
    データベースのテーブルまたはビューの全行に対するビジネスロジックを処理する単一のインスタンス。
* **サービスレイヤー (Service Layer)**
    利用可能な操作のセットを定義し、各操作におけるアプリケーションの応答を調整するサービス層によって、アプリケーションの境界を定義する。

## データソース・アーキテクチャ・パターン (Data Source Architectural Patterns)

* **テーブルデータゲートウェイ (Table Data Gateway)**
    データベーステーブルへのゲートウェイとして機能するオブジェクト。1つのインスタンスがテーブル内の全行を処理する。
* **行データゲートウェイ (Row Data Gateway)**
    データソース内の単一のレコードへのゲートウェイとして機能するオブジェクト。1行につき1つのインスタンスが存在する。
* **アクティブレコード (Active Record)**
    データベースのテーブルやビューの1行をラップし、データベースアクセスをカプセル化し、そのデータに対するドメインロジックを追加したオブジェクト。
* **データマッパー (Data Mapper)**
    オブジェクトとデータベースを互いに独立させたまま、両者の間でデータを移動させるマッパー層。

## オブジェクト・リレーショナル振る舞いパターン (Object-Relational Behavioral Patterns)

* **ユニットオブワーク (Unit of Work)**
    ビジネストランザクションの影響を受けるオブジェクトのリストを保持し、変更の書き出しと並行性問題の解決を調整する。
* **アイデンティティマップ (Identity Map)**
    すべてのロード済みオブジェクトをマップに保持することで、各オブジェクトが一度だけロードされることを保証する。オブジェクトを参照する際は、このマップを使用して検索する。
* **遅延ロード (Lazy Load)**
    必要なすべてのデータを含んでいるわけではないが、そのデータの取得方法を知っているオブジェクト。

## オブジェクト・リレーショナル構造パターン (Object-Relational Structural Patterns)

* **アイデンティティフィールド (Identity Field)**
    メモリ上のオブジェクトとデータベースの行の間の同一性を維持するために、オブジェクト内にデータベースのIDフィールドを保存する。
* **継承マッパー (Inheritance Mappers)**
    継承階層を処理するデータベースマッパーを整理するための構造。
* **外部キーマッピング (Foreign Key Mapping)**
    オブジェクト間の関連を、テーブル間の外部キー参照にマッピングする。
* **関連テーブルマッピング (Association Table Mapping)**
    関連を、リンクされたテーブルへの外部キーを持つ独立したテーブルとして保存する。
* **依存マッピング (Dependent Mapping)**
    あるクラスに、その子クラスのデータベースマッピングを実行させる。
* **埋め込み値 (Embedded Value)**
    オブジェクトを、別のオブジェクトのテーブル内の複数のフィールドにマッピングする。
* **シリアル化LOB (Serialized LOB)**
    オブジェクトのグラフをシリアル化して単一のラージオブジェクト（LOB）にし、データベースのフィールドに保存する。
* **単一テーブル継承 (Single Table Inheritance)**
    クラスの継承階層を、全クラスの全フィールドに対応するカラムを持つ単一のテーブルとして表現する。
* **クラステーブル継承 (Class Table Inheritance)**
    クラスの継承階層を、各クラスにつき1つのテーブルで表現する。
* **具象テーブル継承 (Concrete Table Inheritance)**
    クラスの継承階層を、階層内の各具象クラスにつき1つのテーブルで表現する。

## オブジェクト・リレーショナル・メタデータマッピング・パターン (Object-Relational Metadata Mapping Patterns)

* **メタデータマッピング (Metadata Mapping)**
    オブジェクト・リレーショナル・マッピングの詳細をメタデータに保持する。
* **クエリオブジェクト (Query Object)**
    データベースクエリを表現するオブジェクト。
* **リポジトリ (Repository)**
    ドメインオブジェクトへのアクセスにコレクションのようなインターフェースを使用し、ドメイン層とデータマッピング層の間を仲介する。

## Webプレゼンテーション・パターン (Web Presentation Patterns)

* **モデル・ビュー・コントローラ (Model View Controller)**
    ユーザーインターフェースの相互作用を3つの明確な役割に分割する。
* **ページコントローラ (Page Controller)**
    Webサイト上の特定のページまたはアクションのリクエストを処理するオブジェクト。
* **フロントコントローラ (Front Controller)**
    Webサイトのすべてのリクエストを処理する単一のコントローラ。
* **テンプレートビュー (Template View)**
    HTMLページにマーカーを埋め込むことで、情報をHTMLとしてレンダリングする。
* **トランスフォームビュー (Transform View)**
    ドメインデータを要素ごとに処理し、HTMLに変換するビュー。
* **2段階ビュー (Two Step View)**
    ドメインデータを2つのステップでHTMLに変換する。まず論理的なページを形成し、次にその論理ページをHTMLとしてレンダリングする。
* **アプリケーションコントローラ (Application Controller)**
    画面遷移とアプリケーションのフローを処理するための中心点。

## 分散パターン (Distribution Patterns)

* **リモートファサード (Remote Facade)**
    ネットワーク越しの効率を向上させるため、粒度の細かいオブジェクトに対して粗粒度のファサードを提供する。
* **データ転送オブジェクト (Data Transfer Object / DTO)**
    メソッド呼び出しの回数を減らすために、プロセス間でデータを運ぶオブジェクト。

## オフライン並行性パターン (Offline Concurrency Patterns)

* **楽観的オフラインロック (Optimistic Offline Lock)**
    競合を検出してトランザクションをロールバックすることで、並行するビジネストランザクション間の競合を防ぐ。
* **悲観的オフラインロック (Pessimistic Offline Lock)**
    一度に1つのビジネストランザクションのみがデータにアクセスできるようにすることで、並行するビジネストランザクション間の競合を防ぐ。
* **粗粒度ロック (Coarse-Grained Lock)**
    関連するオブジェクトのセットを単一のロックでロックする。
* **暗黙的ロック (Implicit Lock)**
    フレームワークやレイヤースーパータイプのコードがオフラインロックを自動的に取得できるようにする。

## セッション状態パターン (Session State Patterns)

* **クライアントセッション状態 (Client Session State)**
    セッション状態をクライアント側に保存する。
* **サーバーセッション状態 (Server Session State)**
    セッション状態をサーバーシステム上にシリアル化された形式で保持する。
* **データベースセッション状態 (Database Session State)**
    セッションデータをコミット済みデータとしてデータベースに保存する。

## 基本パターン (Base Patterns)

* **ゲートウェイ (Gateway)**
    外部システムまたはリソースへのアクセスをカプセル化するオブジェクト。
* **サービススタブ (Service Stub)**
    テスト中に、問題の原因となる可能性のあるサービスへの依存を取り除く。
* **レコードセット (Record Set)**
    テーブルデータのメモリ上の表現。
* **マッパー (Mapper)**
    2つの独立したオブジェクト間の通信をセットアップするオブジェクト。
* **レイヤースーパータイプ (Layer Supertype)**
    あるレイヤー内のすべての型のスーパータイプ（親クラス）として機能する型。
* **分離インターフェース (Separated Interface)**
    実装とは別のパッケージでインターフェースを定義する。
* **レジストリ (Registry)**
    他のオブジェクトが共通のオブジェクトやサービスを見つけるために使用できる、よく知られたオブジェクト。
* **値オブジェクト (Value Object)**
    通貨や日付範囲のような、同一性（アイデンティティ）に基づかない等価性を持つ、小さく単純なオブジェクト。
* **マネー (Money)**
    金銭的な値を表現する。
* **スペシャルケース (Special Case)**
    特定のケースに対して特別な振る舞いを提供するサブクラス。
* **プラグイン (Plugin)**
    コンパイル時ではなく、設定時にクラスをリンクする。

## Patterns of Enterprise Application Architectureの詳細

### 1. ドメインロジック・パターン (Domain Logic Patterns)

ビジネスロジック（業務ルール）をどのように整理・配置するかを定義するパターンです。

#### ■ トランザクションスクリプト (Transaction Script)

* **概要:** ユーザーからの1つの要求（トランザクション）に対して、1つの手続き（メソッドや関数）を対応させ、その中にすべてのビジネスロジックを記述する方法です。
* **特徴:** データベースのテーブルとほぼ1対1で対応する処理を書くことが多く、手続き型のプログラミングスタイルになります。
* **メリット:** 構造が単純で理解しやすく、開発が非常に速いです。小規模なシステムに適しています。
* **デメリット:** システムが大規模になると、似たようなコードが重複し、修正が困難（スパゲッティコード化）になります。

#### ■ ドメインモデル (Domain Model)

* **概要:** 現実世界の「モノ」や「概念」をオブジェクトとして表現し、そのオブジェクトの中に「データ」と「振る舞い（ロジック）」の両方を持たせる方法です。
* **特徴:** オブジェクト指向の特性（継承、ポリモーフィズム、カプセル化）をフルに活用します。
* **メリット:** 複雑なビジネスルールを整理しやすく、長期的な保守性が高いです。
* **デメリット:** データベースとのマッピング（ORマッピング）が難しく、習得に時間がかかります。

#### ■ テーブルモジュール (Table Module)

* **概要:** データベースの「テーブルごと」に1つのクラスを作成し、そのテーブルの全データに対するロジックをそのクラスに集約する方法です。
* **特徴:** ドメインモデルが「1つのレコード ＝ 1つのオブジェクト」なのに対し、テーブルモジュールは「1つのテーブル ＝ 1つのオブジェクト」として扱います。
* **メリット:** .NETのDataSetなどの「レコードセット」を扱うライブラリと非常に相性が良く、ドメインモデルより構造がシンプルです。
* **デメリット:** オブジェクト指向の強力な機能（継承など）を活用しにくいです。

#### ■ サービスレイヤー (Service Layer)

* **概要:** プレゼンテーション層（画面）とドメイン層（ロジック）の間に境界線を引き、アプリケーションが提供する「操作」を一覧化した層です。
* **特徴:** トランザクションの制御やセキュリティチェックなど、複数のドメインオブジェクトをまたぐ処理を調整（コーディネート）します。
* **メリット:** クライアント（Web、アプリ、APIなど）に対して一貫したインターフェースを提供でき、ロジックの再利用性が高まります。
* **デメリット:** ロジックが薄い場合、単に下の層を呼び出すだけの「パススルー」なコードが増え、冗長になることがあります。

### 2. データソース・アーキテクチャ・パターン (Data Source Architectural Patterns)

#### ■ テーブルデータゲートウェイ (Table Data Gateway)

* **概要:** データベースの1つの「テーブル」に対して、1つのオブジェクトを用意し、そのテーブルへのアクセス（SELECT, INSERT, UPDATE, DELETE）をすべて引き受ける方法です。
* **特徴:** インスタンスは1つだけで、メソッドの引数や戻り値として「ID」や「レコードセット」をやり取りします。SQLを1箇所に集約できます。
* **メリット:** 構造が非常にシンプルで、「トランザクションスクリプト」や「テーブルモジュール」と非常に相性が良いです。
* **デメリット:** 戻り値が単純なデータ構造（マップやリスト）になりがちで、複雑なドメインロジックを持たせるのには向きません。

#### ■ 行データゲートウェイ (Row Data Gateway)

* **概要:** データベースの「1つの行（レコード）」に対して、1つのオブジェクトを対応させる方法です。
* **特徴:** オブジェクトの各フィールドがカラムに対応します。ただし、このオブジェクトには**ビジネスロジックは含めず**、データの保持とデータベースへの保存機能のみを持たせます。
* **メリット:** SQLをビジネスロジックから完全に隠蔽でき、データ構造をオブジェクトとして扱いやすくなります。
* **デメリット:** 「1行ごとに1つのインスタンス」を作るため、大量のデータを扱う際にメモリ管理に注意が必要です。また、ロジックを持つドメインモデルとデータを持つゲートウェイでクラスが二重になりがちです。

#### ■ アクティブレコード (Active Record)

* **概要:** 「行データゲートウェイ」に「ドメインロジック（業務ルール）」を合体させたパターンです。
* **特徴:** 1つのクラスが、データの持ち方、データベース操作（保存・削除）、およびそのデータに関連するロジックのすべてを受け持ちます。Ruby on Railsなどで採用され、非常に有名になりました。
* **メリット:** 学習コストが低く、直感的で開発スピードが極めて速いです。単純〜中規模のアプリケーションに最適です。
* **デメリット:** クラスが「データの保持」「DB操作」「ビジネスロジック」という多くの責任を負うため、複雑すぎるシステムではクラスが肥大化（ファットモデル化）しやすいです。

#### ■ データマッパー (Data Mapper)

* **概要:** ドメインオブジェクト（ロジック担当）と、データベース（データ保存担当）を完全に切り離し、その間を仲介する「マッパー」を用意するパターンです。
* **特徴:** ドメインオブジェクト側は、自分がデータベースに保存される仕組みを一切知りません。マッパーが裏側で、オブジェクトの値をテーブルへ、テーブルの値をオブジェクトへと移し替えます。
* **メリット:** ドメインモデルをデータベースの構造から完全に独立させることができるため、最も柔軟で、非常に複雑なビジネスロジックを扱う大規模開発に適しています。
* **デメリット:** 仕組みが複雑で、構築に手間がかかります。HibernateやEntity Frameworkなどの高度なライブラリ（ORマッパー）が必要になることが多いです。

### 3. オブジェクト・リレーショナル振る舞いパターン (Object-Relational Behavioral Patterns)

#### ■ ユニットオブワーク (Unit of Work)

* **概要:** 1つのビジネストランザクション（一連の処理）の中で、作成・更新・削除されたオブジェクトをすべて追跡し、最後にまとめてデータベースに反映させる仕組みです。
* **特徴:** 処理の途中で何度もDBに書き込むのではなく、最後に一括で「差分」を書き込みます。これにより、DBとの通信回数を減らし、一貫性を保ちます。
* **メリット:** データベースの負荷を軽減でき、トランザクションの整合性（すべて成功か、すべて失敗か）を確実に管理できます。
* **デメリット:** システム全体で導入する必要があり、実装が複雑になりがちです。

#### ■ アイデンティティマップ (Identity Map)

* **概要:** データベースから読み込んだすべてのオブジェクトを「マップ（連想配列など）」に記録しておき、同じデータを二度読み込まないようにする仕組みです。
* **特徴:** 「ID: 1 のユーザー」を一度読み込んだら、次に同じIDが必要になったときはDBへ行かず、メモリ上のマップから同じインスタンスを返します。
* **メリット:** 1つの処理の中で同じデータに対して複数のインスタンスが存在してしまう（一方は更新されているが、もう一方は古いまま、といった状態）のを防げます。
* **デメリット:** 大量のオブジェクトをメモリに保持し続けるとメモリを圧迫するため、管理（キャッシュの破棄タイミングなど）が必要です。

#### ■ 遅延ロード (Lazy Load)

* **概要:** オブジェクトをデータベースから読み込む際、関連するすべてのデータを一度に取得せず、実際にそのデータが必要になった（アクセスされた）瞬間に初めて読み込む手法です。
* **特徴:** 例えば「注文データ」を読み込むとき、重たい「注文明細の画像データ」などは最初は読み込まず、画面に表示する直前にDBへ取りに行きます。
* **メリット:** 起動時や初期読み込みのスピードが劇的に向上し、不要なデータの取得を避けられます。
* **デメリット:** 「N+1問題」（ループの中で1件ずつDBにアクセスしてしまい、逆に遅くなる問題）を引き起こしやすいため、注意深い設計が必要です。

### 4. オブジェクト・リレーショナル構造パターン (Object-Relational Structural Patterns)

#### ■ アイデンティティフィールド (Identity Field)

* **概要:** データベースの主キー（ID）をオブジェクトのフィールドとして保持する手法です。
* **特徴:** メモリ上のオブジェクトが、DBのどの行に対応するかを一意に特定できるようにします。
* **メリット:** オブジェクトとDB行の同一性が保証され、更新や削除の対象を正確に指定できます。
* **デメリット:** オブジェクト側に「ビジネス上は不要なID」を持たせる必要があり、純粋なドメインロジックにDBの都合が混じります。

#### ■ 継承マッパー (Inheritance Mappers)

* **概要:** クラスの継承階層（親クラス・子クラス）をDBに保存・取得するためのマッパーの構造です。
* **特徴:** 後述する3つの継承パターン（単一、クラス、具象テーブル）を適切に使い分けるための設計方針です。
* **メリット:** 複雑なクラス階層をRDBで管理しやすくなります。
* **デメリット:** 継承が深くなるとマッピングが非常に複雑になり、パフォーマンス低下を招くことがあります。

#### ■ 外部キーマッピング (Foreign Key Mapping)

* **概要:** オブジェクト間の関連（1対多など）を、DBの「外部キー」として表現する方法です。
* **特徴:** オブジェクト側では「参照」ですが、DB側では「ID（外部キー）」として保存します。
* **メリット:** RDBの標準的な仕組みを利用するため、クエリが書きやすく整合性も保ちやすいです。
* **デメリット:** オブジェクトをロードする際に、関連するオブジェクトも読み込む必要があり、遅延ロード等の工夫が必要になります。

#### ■ 関連テーブルマッピング (Association Table Mapping)

* **概要:** 「多対多」の関連を、2つのテーブルを繋ぐ「中間テーブル（関連テーブル）」を使って表現する方法です。
* **特徴:** どちらのテーブルにも相手のキーを持たせず、第3のテーブルが双方のIDをペアで保持します。
* **メリット:** 多対多の関係を矛盾なく保存でき、関連自体に属性（作成日など）を持たせることも可能です。
* **デメリット:** データ取得に必ずJOINが必要になり、処理が少し重くなります。

#### ■ 依存マッピング (Dependent Mapping)

* **概要:** あるオブジェクト（親）に関連する小さなオブジェクト（子）のマッピングを、親側がまとめて行う手法です。
* **特徴:** 子オブジェクト自身はID（主キー）を持たず、親のテーブルの一部や関連としてのみ存在します。
* **メリット:** 子オブジェクトごとのID管理が不要になり、DBの構造を簡略化できます。
* **デメリット:** 子オブジェクトを単体で検索したり、他のオブジェクトから参照したりすることができなくなります。

#### ■ 埋め込み値 (Embedded Value)

* **概要:** オブジェクト（例：金額クラス）を、別のオブジェクト（例：注文クラス）のテーブル内にある「複数のカラム」として保存する方法です。
* **特徴:** 金額クラスの「数値」と「通貨単位」を、注文テーブルの2つのカラムに直接埋め込みます。
* **メリット:** テーブルのJOINを減らすことができ、オブジェクト指向の「値オブジェクト」をきれいに永続化できます。
* **デメリット:** 埋め込まれた値を使って複数のテーブルをまたぐ複雑な集計をするのが難しくなる場合があります。

#### ■ シリアル化LOB (Serialized LOB)

* **概要:** オブジェクトのグラフ（複数の関連するオブジェクト）を、XMLやJSONなどにシリアル化して、DBのLOB（Large Object）フィールドに丸ごと保存する方法です。
* **特徴:** DB側では単なる「長い文字列/バイナリ」として扱われます。
* **メリット:** 非常に複雑な構造を1つのフィールドに瞬時に保存でき、DBスキーマの変更も不要です。
* **デメリット:** そのフィールド内の特定の項目を使ってSQLで検索や集計をすることが困難（または不可能）になります。

#### ■ 単一テーブル継承 (Single Table Inheritance)

* **概要:** 継承階層にあるすべてのクラス（親とすべての子）を、1つの大きなテーブルに保存する方法です。
* **特徴:** すべての子クラスの全属性（カラム）を1テーブルにまとめ、どのクラスかを示す「識別子カラム」を持ちます。
* **メリット:** 検索時にJOINが一切不要で、パフォーマンスが非常に高いです。
* **デメリット:** 自分のクラスでは使わないカラムが「NULL」だらけになり、テーブルが肥大化しやすいです。

#### ■ クラステーブル継承 (Class Table Inheritance)

* **概要:** 継承階層のクラスごとに1つのテーブルを作成する方法です。
* **特徴:** 親テーブルには共通属性、子テーブルには独自属性を保存し、主キーで紐づけます。
* **メリット:** DB構造がクラス階層と一致し、データの重複がなく、正規化されたきれいな形になります。
* **デメリット:** 1つのオブジェクトを読み込むのに親・子のテーブルをJOINする必要があり、パフォーマンスに影響します。

#### ■ 具象テーブル継承 (Concrete Table Inheritance)

* **概要:** インスタンス化される具体的なクラス（具象クラス）ごとにテーブルを作成する方法です。
* **特徴:** 親クラス用のテーブルは作らず、各子テーブルが親の共通属性もすべてカラムとして持ちます。
* **メリット:** 特定のクラスのデータを取得する際、JOINなしで1つのテーブルからすべて取得できます。
* **デメリット:** 親クラスの共通属性を変更すると、すべての具象テーブルのスキーマを変更しなければならず、管理が大変です。

### 5. オブジェクト・リレーショナル・メタデータマッピング・パターン (Object-Relational Metadata Mapping Patterns)

#### ■ メタデータマッピング (Metadata Mapping)

* **概要:** オブジェクトのフィールドとデータベースのカラムの対応関係を、プログラム内に直接記述するのではなく、「メタデータ（設定ファイル、アノテーション、または専用の定義コード）」として保持する手法です。
* **特徴:** 汎用的なマッパーがこのメタデータを読み込み、実行時にSQLを自動生成してデータを移し替えます。
* **メリット:** マッピングのルールが一箇所に集約され、データベースの変更に対してコードを大幅に書き換える必要がなくなります。
* **デメリット:** メタデータの定義そのものが複雑になりがちで、実行時の挙動がブラックボックス化しやすいため、デバッグに苦労することがあります。

#### ■ クエリオブジェクト (Query Object)

* **概要:** データベースへの問い合わせ（クエリ）を、SQL文字列としてではなく、ひとつの「オブジェクト」として表現する手法です。
* **特徴:** 「WHERE句の条件」や「ソート順」をオブジェクトのメソッドやプロパティを使って組み立てます。現代のORマッパー（HibernateのCriteria APIなど）でよく見られる形式です。
* **メリット:** SQL injectionを防ぎやすく、動的なクエリ（画面入力に応じた検索条件の変更など）を安全かつ柔軟に作成できます。
* **デメリット:** 極めて複雑なJOINや、データベース固有の特殊な関数を多用するクエリを表現しようとすると、実装コストが非常に高くなります。

#### ■ リポジトリ (Repository)

* **概要:** ドメインオブジェクトの集合（メモリ上のコレクションやリスト）のように振る舞い、データアクセスを完全に隠蔽するインターフェースです。
* **特徴:** ドメイン層とデータマッピング層の間に立ち、「特定の条件に合うオブジェクトを探す」「オブジェクトを保存する」といった操作を、あたかも「リストから探す」かのような直感的なインターフェースで提供します。
* **メリット:** ビジネスロジックが「データベースの存在」を意識しなくて済むようになり、テスト時に「メモリ上のスタブ」へ差し替えることが非常に容易になります。
* **デメリット:** 小規模なアプリでは「データマッパー」や「DAO（Data Access Object）」との役割の違いが曖昧になり、階層が増えることでコードが冗長に感じられることがあります。

### 6. Webプレゼンテーション・パターン (Web Presentation Patterns)

#### ■ モデル・ビュー・コントローラ (Model View Controller / MVC)

* **概要:** UIの機能を「Model（データとロジック）」「View（表示）」「Controller（入力制御）」の3つの役割に分離する、最も有名なパターンです。
* **特徴:** ユーザーの入力をコントローラが受け取り、モデルを操作し、その結果をビューに反映させて表示します。
* **メリット:** 画面デザインとビジネスロジックを切り離せるため、変更に強く、それぞれの専門スタッフ（デザイナーとプログラマーなど）が作業を分担しやすくなります。
* **デメリット:** 小規模な画面では役割分担が過剰になり、コード量が増えて複雑に感じられることがあります。

#### ■ ページコントローラ (Page Controller)

* **概要:** Webサイトの「特定のページ」や「特定のアクション」ごとに、1つのコントローラ（ハンドラ）を割り当てる手法です。
* **特徴:** `login.php` や `register.aspx` のように、URLのパスと処理コードが1対1で対応する形が典型的です。
* **メリット:** 構造が非常に単純で、特定のページの挙動を確認・修正するのが容易です。
* **デメリット:** サイト全体で共通の処理（ログインチェックや文字エンコーディングの設定など）を各ページに書かなければならず、重複が発生しやすくなります。

#### ■ フロントコントローラ (Front Controller)

* **概要:** Webサイトへのすべてのリクエストを「単一の窓口（コントローラ）」で受け取り、そこから適切な処理へと振り分ける手法です。
* **特徴:** 現代の主要なWebフレームワーク（Spring, Rails, Laravelなど）の多くが採用しています。すべてのアクセスが必ず1点を通ります。
* **メリット:** 認証、ログ記録、言語切り替えなどの「共通処理」を一箇所に集約できるため、コードの重複を防ぎ、セキュリティも高められます。
* **デメリット:** 振り分け設定（ルーティング）が複雑になると、全体の流れを把握するのに手間がかかるようになります。

#### ■ テンプレートビュー (Template View)

* **概要:** HTMLの中に特別なマーカーやコードを埋め込み、実行時に動的なデータを流し込んで表示を作成する手法です。
* **特徴:** JSP, Thymeleaf, ERB, Bladeなどのテンプレートエンジンがこれに当たります。基本はHTMLなので見た目が分かりやすいです。
* **メリット:** HTMLのデザインを維持したまま動的な値を埋め込めるため、画面のレイアウト構成が直感的で作りやすいです。
* **デメリット:** テンプレートの中に複雑なロジックを書きすぎてしまう（Viewが肥大化する）傾向があり、保守性を下げる原因になりがちです。

#### ■ トランスフォームビュー (Transform View)

* **概要:** ドメインデータをXMLなどの形式で受け取り、変換エンジン（XSLTなど）を使って要素ごとにHTMLへと変換する手法です。
* **特徴:** 「データ」と「見た目」を完全に切り離し、変換ルールによって出力形式（HTML, PDF, JSONなど）を柔軟に変えることができます。
* **メリット:** 同じデータを異なる形式へ変換するのが容易で、ロジックがHTML構造に依存しません。
* **デメリット:** 変換ルールの記述（XSLTなど）が非常に難解になりやすく、学習コストや開発効率の面で課題があります。

#### ■ 2段階ビュー (Two Step View)

* **概要:** ドメインデータをHTMLにする工程を、「論理的なページ構成を作るステップ」と「共通のレイアウト（装飾）を被せるステップ」の2段階に分ける手法です。
* **特徴:** 1段目で「見出し」「本文」「表」などの要素を決め、2段目でサイト全体の共通デザイン（ヘッダー、フッター、サイドバーなど）を適用します。
* **メリット:** サイト全体で一貫したデザインを保ちやすく、個別のページを作る際にレイアウトの詳細を気にする必要がなくなります。
* **デメリット:** 描画プロセスが多層化するため、開発時のデバッグが少し複雑になります。

#### ■ Aplication Controller (Application Controller)

* **概要:** 画面の「遷移（ナビゲーション）」や「実行フロー」を管理するための中心的なオブジェクトです。
* **特徴:** どのボタンを押したらどの画面へ行くか、という「流れ」のルールをコントローラから独立させて管理します。
* **メリット:** 画面遷移のルールを一箇所で集中管理でき、プレゼンテーション層が「次にどこへ行くか」という知識を持たなくて済みます。
* **デメリット:** ページ数が少ない単純なサイトでは、管理の手間だけが増えてしまいメリットが薄いです。

### 7. 分散パターン (Distribution Patterns)

#### ■ リモートファサード (Remote Facade)

* **概要:** ネットワーク越しに操作されるオブジェクトに対して、複数の細かい処理を1回で済ませられるような「粗粒度（おおまか）」なインターフェースを提供する手法です。
* **特徴:** ドメイン層にある「住所設定」「氏名設定」「電話番号設定」といった細かいメソッドを直接公開せず、「プロフィール一括更新」という1つのメソッドとしてまとめ、外部に公開します。
* **メリット:** ネットワークの通信回数を劇的に減らすことができ、アプリケーションのレスポンス性能が向上します。また、内部の複雑なドメインモデルを外部にさらさずに済みます。
* **デメリット:** 呼び出し側が「一部だけ変更したい」場合でも大きな単位で呼び出す必要があり、インターフェースの柔軟性が低くなることがあります。

#### ■ データ転送オブジェクト (Data Transfer Object / DTO)

* **概要:** プロセス間でデータを転送するためだけに作られた、ロジックを持たない単純なデータ保持用オブジェクトです。
* **特徴:** 複数のフィールドを1つのオブジェクトに詰め込み、1回の通信でまとめて送信します。通常、シリアル化（JSONやXMLへの変換）しやすい構造になっています。
* **メリット:** 「リモートファサード」と同様に通信回数を削減できます。また、ドメインオブジェクト（ビジネスロジックを含む重いオブジェクト）を直接ネットワークに流さないため、セキュリティや依存関係の切り離しに役立ちます。
* **デメリット:** ドメインオブジェクトとほぼ同じ内容を持つ「似て非なるクラス」が大量に増えてしまい、それらの間で値を詰め替える作業（マッピング）に手間がかかります。

### 8. オフライン並行性パターン (Offline Concurrency Patterns)

#### ■ 楽観的オフラインロック (Optimistic Offline Lock)

* **概要:** 「競合はめったに起こらない」と考え、データの読み込み時にはロックをかけず、保存する瞬間に他人が更新していないかを確認する手法です。
* **特徴:** データに「バージョン番号」や「更新日時」を持たせておきます。保存時に、自分が読み込んだ時のバージョンとDBの現在のバージョンが一致していれば更新を許可し、違っていればエラーにします。
* **メリット:** データベースの接続やロックを長時間保持しないため、システム全体の拡張性（スケーラビリティ）が高く、最も一般的に使われます。
* **デメリット:** 編集が終わって保存しようとした瞬間に「他の人が更新済みです」とエラーが出るため、ユーザーがそれまでの作業内容を失うリスクがあります。

#### ■ 悲観的オフラインロック (Pessimistic Offline Lock)

* **概要:** 「競合が起こる可能性が高い」と考え、あるユーザーが編集を開始した時点で、他のユーザーがそのデータを編集できないようにロックをかけてしまう手法です。
* **特徴:** 専用のロック管理テーブルなどを用意し、「誰が、どのデータを編集権限として持っているか」を記録します。
* **メリット:** 編集を開始できた時点で「最後に保存できること」が保証されるため、ユーザーが長時間の作業を無駄にする心配がありません。
* **デメリット:** 並行性が著しく低下します。また、ユーザーが画面を開いたままブラウザを閉じたり、離席したりした場合にロックが残り続けてしまうため、タイムアウト処理などの複雑な管理が必要になります。

#### ■ 粗粒度ロック (Coarse-Grained Lock)

* **概要:** 関連する複数のオブジェクト（例：注文ヘッダーとその複数の注文明細）を、1つの大きな単位としてまとめてロックする手法です。
* **特徴:** 明細を1つずつロックするのではなく、親である「注文全体」に対して1つのロックを取得します。
* **メリット:** ロックの管理が単純になり、デッドロック（お互いにロックし合って動けなくなる状態）を防ぎやすくなります。また、関連データ間での不整合を防げます。
* **デメリット:** 実際には競合しない部分までロックしてしまう可能性があり、他のユーザーの作業を不必要に妨げてしまう（並行性が下がる）ことがあります。

#### ■ 暗黙的ロック (Implicit Lock)

* **概要:** アプリケーションのコード内で明示的に「ロック取得」と書かなくても、フレームワークや共通基盤が自動的にロックをかけてくれる仕組みです。
* **特徴:** 「レイヤースーパータイプ」などの仕組みを利用し、データ取得処理が行われる際に裏側で自動的に楽観的または悲観的ロックを実行します。
* **メリット:** 開発者がロックの取得を忘れるといったミスを防ぐことができ、ビジネスロジックのコードがすっきりします。
* **デメリット:** 「裏で勝手にロックがかかる」ため、特定の処理だけロックを外したいといった細かい制御が難しくなったり、挙動の把握が難しくなったりすることがあります。

### 9. セッション状態パターン (Session State Patterns)

#### ■ クライアントセッション状態 (Client Session State)

* **概要:** セッションデータをサーバー側ではなく、クライアント（ブラウザ）側に保存する手法です。
* **特徴:** クッキー（Cookie）、URLパラメータ、またはHTMLの隠しフィールド（Hidden Field）にデータを埋め込んで、リクエストのたびにサーバーへ送信します。
* **メリット:** サーバー側のリソース（メモリやDB）を一切消費しません。サーバーを再起動してもデータが消えず、複数のサーバーで負荷分散している場合でも「どのサーバーにアクセスしても同じデータが使える」という利点があります。
* **デメリット:** ユーザーによる「データの改ざん」のリスクがあるため、重要なデータの保存には暗号化や署名が必須です。また、データ量が多いと通信量が増え、ネットワークの帯域を圧迫します。

#### ■ サーバーセッション状態 (Server Session State)

* **概要:** セッションデータをアプリケーションサーバー上のメモリ内に保持する手法です。
* **特徴:** ブラウザには「セッションID」だけを渡し、サーバー側でそのIDに関連付けられたオブジェクトをメモリ上に置いておきます。
* **メリット:** サーバー内のメモリにアクセスするだけなので非常に高速です。また、シリアル化（データ変換）の手間なく、複雑なオブジェクトをそのまま保持できます。
* **デメリット:** サーバーのメモリを大量に消費するため、ユーザー数が増えるとパンクする恐れがあります。また、サーバーを再起動するとデータが消えてしまうほか、複数サーバー構成の場合は「同じユーザーは必ず同じサーバーに送る（スティッキーセッション）」仕組みが必要になります。

#### ■ データベースセッション状態 (Database Session State)

* **概要:** セッションデータをデータベースや外部の高速なストレージ（RedisなどのインメモリDB）に保存する手法です。
* **特徴:** ユーザーがリクエストを送るたびに、サーバーは外部DBからセッション情報を読み込み、処理が終わると書き戻します。
* **メリット:** サーバーがいつ再起動してもデータが失われません。また、すべてのサーバーが同じDBを参照するため、どのサーバーがリクエストを処理しても一貫した状態を保つことができ、スケールアウトが容易です。
* **デメリット:** 毎回ネットワーク越しにDBへアクセスするため、サーバー内メモリを使う場合に比べてわずかな遅延（レイテンシ）が発生します。また、保存のためにオブジェクトをバイト列などに変換（シリアル化）する処理が必要になります。

### 10. 基本パターン (Base Patterns)

#### ■ ゲートウェイ (Gateway)

* **概要:** 外部システム（DB、API、外部ファイルなど）へのアクセスを専用のオブジェクトで包み込み、複雑な接続手順を隠蔽する手法です。
* **特徴:** 呼び出し側は「どうやって接続するか」を知る必要がなく、単純なメソッド呼び出しだけで済みます。
* **メリット:** 外部システムの仕様変更があってもゲートウェイ内を修正するだけで済み、テスト時に「偽物」と差し替えやすくなります。
* **デメリット:** 単純なアクセスであってもクラスを作る必要があるため、コード量が増える場合があります。

#### ■ サービススタブ (Service Stub)

* **概要:** テスト時に、外部システムや不安定なサービスの代わりに機能する「仮の代用品（スタブ）」です。
* **特徴:** ネットワーク通信を行わず、常に決まった（あるいはシミュレートされた）値を返します。
* **メリット:** 外部システムが未完成だったり停止していても、自分のコードのテストを進めることができます。
* **デメリット:** 本物のサービスの挙動とスタブの挙動にズレが生じると、テストが通っても本番で動かない原因になります。

#### ■ レコードセット (Record Set)

* **概要:** データベースのテーブルデータを、メモリ上で扱いやすい「表形式（行と列）」のデータ構造として表現したものです。
* **特徴:** 1つのオブジェクトが複数の行とカラムを持ち、フィルタリングやソートが可能です。.NETの`DataSet`などが典型例です。
* **メリット:** データベースの構造をそのまま扱えるため、汎用的なツール（画面表示コントロールなど）と非常に相性が良いです。
* **デメリット:** 型の安全性が低くなりやすく（文字列でカラム名を指定するなど）、オブジェクト指向の恩恵を受けにくい面があります。

#### ■ マッパー (Mapper)

* **概要:** 互いを知らない2つの独立したオブジェクトを、その間の通信を肩代わりすることで連携させる手法です。
* **特徴:** 「データマッパー」が代表例ですが、それ以外でも、異なる形式のデータを移し替える処理を独立したクラスに持たせます。
* **メリット:** 連携する両方のオブジェクトが互いに依存しないため、コードの柔軟性と再利用性が高まります。
* **デメリット:** システム内にマッパーという「中間層」が増え、処理の流れを追うのが少し難しくなります。

#### ■ レイヤースーパータイプ (Layer Supertype)

* **概要:** 同じレイヤー（層）にあるすべてのオブジェクトが共通して持つべきプロパティやメソッドを、1つの親クラスにまとめる手法です。
* **特徴:** 例えば、すべてのドメインオブジェクトの共通親クラスとして `DomainObject` を作り、そこに ID フィールドなどを持たせます。
* **メリット:** コードの重複を劇的に減らし、レイヤー全体に共通のルールを強制できます。
* **デメリット:** 継承関係が固定されるため、言語（JavaやC#など）によっては多重継承ができず、設計の自由度が制限されることがあります。

#### ■ 分離インターフェース (Separated Interface)

* **概要:** インターフェース（定義）と、その実装（具体的な中身）を、全く別のパッケージやライブラリに配置する手法です。
* **特徴:** 利用側はインターフェースだけに依存し、実装側については何も知りません。
* **メリット:** 依存関係が逆転し、コンパイル時の依存を切り離せるため、システムのプラグイン化やテストが容易になります。
* **デメリット:** 1つの機能を実現するために、別々の場所にあるファイルを確認・管理しなければならず、管理の手間が増えます。

#### ■ レジストリ (Registry)

* **概要:** 他のオブジェクトが、よく使う共通のオブジェクトやサービスを簡単に見つけるための「住所録（カタログ）」のようなオブジェクトです。
* **特徴:** どこからでもアクセスできる静的なメソッド（Singletonに近い形）で提供されることが多いです。
* **メリット:** 必要なオブジェクトを引数で回し続ける必要がなく、コードのどこからでも必要な機能を取り出せます。
* **デメリット:** 「グローバル変数」に近いため、依存関係が見えにくくなり、テストがしづらくなるリスクがあります。

#### ■ 値オブジェクト (Value Object)

* **概要:** 「ID」による同一性ではなく、持っている「値」そのものが同じであれば等しいとみなす、小さく単純なオブジェクトです。
* **特徴:** 日付、色、座標、電話番号などが該当します。通常、一度作成したら内容を変更できない「不変（Immutable）」として設計します。
* **メリット:** 単なる数値や文字列として扱うよりも意味が明確になり、不正な値（例：マイナスの電話番号）の混入を防げます。
* **デメリット:** 非常に多くの小さなオブジェクトが作成されるため、言語によってはメモリ効率に配慮が必要です。

#### ■ マネー (Money)

* **概要:** 「金額」と「通貨単位」をセットで扱うための、専用の値オブジェクトです。
* **特徴:** 小数点の丸め誤差（10.000...1円など）や、異なる通貨間（円とドル）の計算ミスを防ぐロジックを含みます。
* **メリット:** 金額計算におけるバグ（桁間違いや通貨の混同）をシステム全体で一掃できます。
* **デメリット:** 単純な数値計算（`+`, `-`）に比べると、メソッド呼び出しが必要になり、少し記述が冗長になります。

#### ■ スペシャルケース (Special Case)

* **概要:** 特定の条件（特に「データがない」場合）に対して、`null` を返すのではなく、そのケース専用の「特別な振る舞いをするオブジェクト」を返す手法です。
* **特徴:** 「未ログインユーザー」というクラスを作り、名前を求められたら「ゲスト」と返すようにします。
* **メリット:** 呼び出し側で `if (user == null)` といったチェックが不要になり、コードが劇的にきれいになります。
* **デメリット:** その特別なオブジェクトを予期していない処理が混じると、エラーにならずに「意図しないデフォルト挙動」が続いてしまい、バグの発見が遅れることがあります。

#### ■ プラグイン (Plugin)

* **概要:** 特定の機能の実装を、プログラムのコンパイル時（ビルド時）ではなく、設定ファイルなどを使って「実行時」に決定・切り替えられるようにする仕組みです。
* **特徴:** 「分離インターフェース」を拡張し、環境に応じて実装を差し替えます。
* **メリット:** 本体コードを一切書き換えることなく、新しい機能を追加したり、開発環境と本番環境で挙動を変えたりできます。
* **デメリット:** どのクラスが実際に動いているかがソースコードを見ただけでは分からず、実行時の挙動の把握が難しくなります。

## 参考URL

- https://martinfowler.com/eaaCatalog/

- https://bliki-ja.github.io/DevelopingPatternsOfEnterpriseSoftware/

- https://qiita.com/takaheraw@github/items/46643b42785623f2abf9

- https://tradepaletteftp.com/path/%E3%82%A8%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%9A%E3%83%A9%E3%82%A4%E3%82%B9%E3%82%99%E3%82%A2%E3%83%95%E3%82%9A%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3%E3%83%8F%E3%82%9A%E3%82%BF%E3%83%BC%E3%83%B3.pdf